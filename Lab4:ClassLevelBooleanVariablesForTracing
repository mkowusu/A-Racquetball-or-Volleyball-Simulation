Michael OwusuAnita DeWitt9/21/14Laboratory Exercise: Class-level Boolean Variables for TracingExtra Credit Lab1.Upon running the program with printGame being both true then false, we have found that the program only prints the scores of each game when printGame is true. We found in the main that there is a conditional who's behavior depends on the boolean printGame. When it is true, the program prints the receiver score and the servers score. When it is false, the neither score is printed.2.printGame allows you to check the programs correctness in terms of whether the calculations of who won are actually in agreement with the scores of the game. printGame shows the scores of the receiving team and the serving team so we know precisely how the scores are affected by who serves first. We can also see how the probabilities for winning a volley affects the actual score of the game as opposed to just the percentage of wins.printGame is also  helpful in that it allows a developer to understand how the processing proceeds at a reasonable level of detail. This method is useful in that once printGame is inserted it overcomes the two drawbacks listed in the lab discussion. There is no need to re-insert the print statement because they are controlled by the state of the boolean. This also means that the removal of the print statements is also unnecessary as the print statements can be turned on and off.3.The following code is augmentend with the booleans printGameLevel and printVolleyLevel for tracing of the simulation by game and by level.package volleyballRacquetball;/*  * Racquetball/Volleyball Simulation:   *    Solution Alternative 2:  Store game, simulation data in static variables *    Serve-by-Serve Recursive Approach * Copyright(c) 2011 by Henry M. Walker * * This code is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation. * * This code is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. *  * @author Henry M. Walker * Edited by Michael Owusu and Anita DeWitt 9/21/14 */// The Math library is needed for its random() functionimport java.lang.Math;/** * This class simulates a volleyball or racquetball game * between players/teams A and B, based on the probability * that A will win a volley.  1000 games are simulated, * with the probability of A winning a volley being  * 0.40, 0.41, ..., 0.59, 0.60 . */public class Game3Recur {    // Edit these lines to indicate the game to be simulated    // and the number of games to simulate for each server probability    public static String game = "racquetball"; // "racquetball" or "volleyball"    public static int numberOfGames = 1000;    public static boolean winByTwo;    // use the following fields to enable tracing of results of each game or volley    public static boolean printVolleyLevel = true;    public static boolean printGameLevel= false;    /**     * Format a probability (a number between 0.0 and 1.0)     * as a 2-character integer percentage, followed by a     * "%" character.     */    public static String formatPercent (double value)    {	String str = "" + Math.round(value * 100.0);	while (str.length() < 3)	    str = " " + str;	return str + "%";    }	    /**     * Play one game of racquetball or volleyball to conclusion     * @parms  server and receiver indicate the team "A" or "B"     *         probWinVolley specifies the likelihood the server wins a volley     *         serverScore, recScore contain current score of     *             server and receiver     * @returns winner of game: either "A" or "B"     */    public static String playUntilWin (String server, String receiver,				       double probWinVolley, 				       int serverScore, int recScore)      {  // serve	if (Math.random() < probWinVolley)	    { // score point		serverScore++;		if (printVolleyLevel)			System.out.println ("Winner of Volley " + server + "\n - Current Score:  "					+ serverScore					+ " / " + recScore);	      // if win, return winner		if ((serverScore >= 15)		    && ((! winByTwo)			 || (serverScore >= recScore + 2)))		    { 			if (printGameLevel)			    System.out.println ("Winner: " + server);		      return server;		    }	      // if not win, serve again		{return playUntilWin (server, receiver, probWinVolley, 				      serverScore, recScore);		}	    }	else	    { // other side wins; other player serves 		return playUntilWin (receiver, server, 1.0-probWinVolley,				     recScore, serverScore);	    }    }    /**     * Run simulation of 1000 games for probability of "A" winning     *   a volley covering the range 0.40, 0.41, ..., 0.59, 0.60.     * For each probability of "A" winning,     *   simulate games with Player/Team A always serving first     *   print one line with the percentage of volleys won by A and B      *     and percentage of games won by A and B     */    public static void main (String [] args)    {   // determine if server must win by 2 (e.g., in volleyball)        winByTwo = game.equals("volleyball");	// print headings	System.out.println ("\nSimulation of " + game			    + " based on " + numberOfGames + " games");	System.out.println ("Must win by 2:  " + winByTwo);	System.out.println ();	System.out.println ("    Probabilities         Percentage");	System.out.println (" for winning volley        of Wins");	System.out.println ("     A       B            A        B");        System.out.println ();		// Simulate games for 40% to 60% probabilities for A	for (int prob40To60 = 40; prob40To60 <= 60; prob40To60++)	    {	      double probWinVolley = prob40To60 / 100.0; 	      // Simulate games for a given probability	      int AWins = 0;  // at first neither A nor B has won any games	      int BWins = 0;	      for (int i = 0; i < numberOfGames; i++)		  { // tally winner of game		    if (playUntilWin ("A", "B", probWinVolley, 0, 0).equals("A"))			AWins++;		    else			BWins++;		  }	      System.out.println ("   "			  + formatPercent(probWinVolley)   + "    " 			  + formatPercent(1-probWinVolley) + "         "			  + formatPercent(((double) AWins) / numberOfGames)			  + "     "			  + formatPercent(((double) BWins) / numberOfGames));	    }	System.out.println ("\nEnd of Simulation\n");    }}// Citatations:// 1.// http://www.tutorialspoint.com/java/java_decision_making.htm// For help with else if syntax4.Really we believe you could trace any variable in this simuation that is changing. One that we thought would be helpful would be to trace the probabilities of A or B to win a serve. That would be useful to pair with the game or volley trace so we can see what the exact percentages that yielded the wins and losses for each side.5.Game1Iter1 was revised to show the server as well as their score and that of the receiverRevised Game1Iter1 code:package volleyballRacquetball;/*  * Racquetball/Volleyball Simulation:   *    Solution Alternative 1:  Store game, simulation data in object *    Serve-by-Serve Iterative Approach * Copyright(c) 2011 by Henry M. Walker * * This code is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation. * * This code is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. *  * @author Henry M. Walker * Edited by Michael Owusu and Anita DeWitt on 9/21/14 */// The Math library is needed for its random() functionimport java.lang.Math;/** * This class simulates a volleyball or racquetball game * between players/teams A and B, based on the probability * that A will win a volley.  1000 games are simulated, * with the probability of A winning a volley being  * 0.40, 0.41, ..., 0.59, 0.60 . */public class Game1Iter1 {    public String game; // either "racquetball" or "volleyball"    public boolean winByTwo;    public int numberOfGames;    /**     * Constructor specifies whether racquetball or volleyball     * will be simulated (default racquetball) and      * the number of games to be simulated     * Constructor also uses the racquetball/volleyball      * information to determine if players of the game      * must win by 2 or 1, respectively.     */    public Game1Iter1 (String simGame, int simNumGames)    {	game = simGame;	numberOfGames = simNumGames;   	winByTwo = simGame.equals("volleyball");    }        public static boolean printGame = true;    /**     * Format a probability (a number between 0.0 and 1.0)     * as a 2-character integer percentage, followed by a     * "%" character.     */    public static String formatPercent (double value)    {	String str = "" + Math.round(value * 100.0);	while (str.length() < 3)	    str = " " + str;	return str + "%";    }	 	/**	 * Play one game of racquetball or volleyball to conclusion	 * @parms  probWinVolley specifies the likelihood the server wins a volley	 * @returns winner of game: either "A" or "B"	 */	public String playUntilWin (double probWinVolley)     {	//  start at 0-0	int serverScore = 0;	int receiverScore = 0;	int tempScore;	String server = "A";	String receiver = "B";	String temp;	// continue indefinitely until server wins 	while (true)	    {		// server serves		if (Math.random() < probWinVolley)		    {   // server wins volley			serverScore++;			// check if server wins			if ((serverScore >= 15)			    && ((! winByTwo)				|| serverScore >= receiverScore + 2))			 { if (printGame)				    System.out.println (server + " - Scores:  " 							+ serverScore 							+ " / " + receiverScore);			     return server;			    }		    }		else		    {			// swap information for server and receiver			tempScore = serverScore;			serverScore = receiverScore;			receiverScore = tempScore;			temp = server;			server = receiver;			receiver = temp;			probWinVolley = 1.0 - probWinVolley;		    }	    }     }    /**     * Run simulation of 1000 games for probability of "A" winning     *   a volley covering the range 0.40, 0.41, ..., 0.59, 0.60.     * For each probability of "A" winning,     *   simulate games with Player/Team A always serving first     *   print one line with the percentage of volleys won by A and B      *     and percentage of games won by A and B     */    public void simulateGames ()    {   // print headings	System.out.println ("\nSimulation of " + game			    + " based on " + numberOfGames + " games");	System.out.println ("Must win by 2:  " + winByTwo);	System.out.println ();	System.out.println ("    Probabilities         Percentage");	System.out.println (" for winning volley        of Wins");	System.out.println ("     A       B            A        B");        System.out.println ();		// Simulate games for 40% to 60% probabilities for A	for (int prob40To60 = 40; prob40To60 <= 60; prob40To60++)	    {	      double probWinVolley = prob40To60 / 100.0; 	      // Simulate games for a given probability	      int AWins = 0;  // at first neither A nor B has won any games	      int BWins = 0;	      for (int i = 0; i < numberOfGames; i++)		  { // tally winner of game		    if (playUntilWin (probWinVolley).equals("A"))			AWins++;		    else			BWins++;		  }	      System.out.println ("   "			  + formatPercent(probWinVolley)   + "    " 			  + formatPercent(1-probWinVolley) + "         "			  + formatPercent(((double) AWins) / numberOfGames)			  + "     "			  + formatPercent(((double) BWins) / numberOfGames));	    }	System.out.println ("\nEnd of Simulation\n");    }	/**	 * @parm args is a command-line argument specifies the type of game	 *       "racquetball" indicates server need not win by 2 points	 *       "volleyball" indicates server must win by 2 points	 *       no parameter or other parameter defaults to "racquetball"	 */    public static void main (String [] args)    {	Game1Iter1 rac1 = new Game1Iter1 ("racquetball", 1000);	rac1.simulateGames() ;	Game1Iter1 rac2 = new Game1Iter1 ("volleyball", 500);	rac2.simulateGames();    }	}Game1Iter2 was revised to trace scores of A and BRevised Game1Iter2 code:package volleyballRacquetball;/*  * Racquetball/Volleyball Simulation:   *    Solution Alternative 1:  Store game, simulation data in object *    Iterative Game Approach:  Repeat A serves then B serves until win *                              no helper methods for playing game * Copyright(c) 2011 by Henry M. Walker * * This code is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation. * * This code is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. *  * @author Henry M. Walker * Edited by Michael Owusu and Anita DeWitt 9/21/14 */// The Math library is needed for its random() functionimport java.lang.Math;/** * This class simulates a volleyball or racquetball game * between players/teams A and B, based on the probability * that A will win a volley.  1000 games are simulated, * with the probability of A winning a volley being  * 0.40, 0.41, ..., 0.59, 0.60 . */public class Game1Iter2 {	public String game; // either "racquetball" or "volleyball"	public boolean winByTwo;	public int numberOfGames;	/**	 * Constructor specifies whether racquetball or volleyball	 * will be simulated (default racquetball) and 	 * the number of games to be simulated	 * Constructor also uses the racquetball/volleyball 	 * information to determine if players of the game 	 * must win by 2 or 1, respectively.	 */	public Game1Iter2 (String simGame, int simNumGames)	{		game = simGame;		numberOfGames = simNumGames;		winByTwo = simGame.equals("volleyball");	}	public static boolean printGame = true;	/**	 * Format a probability (a number between 0.0 and 1.0)	 * as a 2-character integer percentage, followed by a	 * "%" character.	 */	public static String formatPercent (double value)	{		String str = "" + Math.round(value * 100.0);		while (str.length() < 3)			str = " " + str;		return str + "%";	}	/**	 * Play one game of racquetball or volleyball to conclusion	 * @parms  probWinVolley specifies the likelihood the server wins a volley	 * @returns winner of game: either "A" or "B"	 */	public String playUntilWin (double probWinVolley) 	{	//  start at 0-0		int AScore = 0;		int BScore = 0;		// continue indefinitely 		//     (until A wins after A's serve or B wins after B's serve)		while (true)		{	// A serves			while (Math.random() < probWinVolley)			{  AScore++;			if ((AScore >= 15)					&& ((! winByTwo)							|| (AScore >= BScore + 2)))			{ if (printGame)				System.out.println (" - Scores (A/B):  " 						+ AScore 						+ " / " + BScore);			return "A";			}			}			// B serves			while (Math.random() < 1.0 - probWinVolley)			{				BScore++;				if ((BScore >= 15)						&& ((! winByTwo)								|| (BScore >= AScore + 2)))				{ if (printGame)					System.out.println (" - Scores (A/B):  " 							+ AScore 							+ " / " + BScore);  				return "B";				}			}		}	}	/**	 * Run simulation of 1000 games for probability of "A" winning	 *   a volley covering the range 0.40, 0.41, ..., 0.59, 0.60.	 * For each probability of "A" winning,	 *   simulate games with Player/Team A always serving first	 *   print one line with the percentage of volleys won by A and B 	 *     and percentage of games won by A and B	 */	public void simulateGames ()	{   // print headings		System.out.println ("\nSimulation of " + game				+ " based on " + numberOfGames + " games");		System.out.println ("Must win by 2:  " + winByTwo);		System.out.println ();		System.out.println ("    Probabilities         Percentage");		System.out.println (" for winning volley        of Wins");		System.out.println ("     A       B            A        B");		System.out.println ();		// Simulate games for 40% to 60% probabilities for A		for (int prob40To60 = 40; prob40To60 <= 60; prob40To60++)		{			double probWinVolley = prob40To60 / 100.0;			// Simulate games for a given probability			int AWins = 0;  // at first neither A nor B has won any games			int BWins = 0;			for (int i = 0; i < numberOfGames; i++)			{ // tally winner of game				//System.out.print ("game " + i +" \t prob "+ probWinVolley);				if (playUntilWin (probWinVolley).equals("A"))					AWins++;				else					BWins++;			}			System.out.println ("   "					+ formatPercent(probWinVolley)   + "    " 					+ formatPercent(1-probWinVolley) + "         "					+ formatPercent(((double) AWins) / numberOfGames)					+ "     "					+ formatPercent(((double) BWins) / numberOfGames));		}	}	/**	 * @parm args is a command-line argument specifies the type of game	 *       "racquetball" indicates server need not win by 2 points	 *       "volleyball" indicates server must win by 2 points	 *       no parameter or other parameter defaults to "racquetball"	 */	public static void main (String [] args)	{		Game1Iter2 rac1 = new Game1Iter2 ("racquetball", 1000);		rac1.simulateGames();		Game1Iter2 rac2 = new Game1Iter2 ("volleyball", 500);		rac2.simulateGames();	}	}Game1Iter2Alt was revised to trace scores of A and BRevised Game1Iter2Alt code:package volleyballRacquetball;/*  * Racquetball/Volleyball Simulation:   *    Solution Alternative 1:  Store game, simulation data in object *    Iterative Game Approach:  Repeat A serves then B serves until win *                              uses helper methods when playing game * Copyright(c) 2011 by Henry M. Walker * * This code is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation. * * This code is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. *  * @author Henry M. Walker * Edited by Michael Owusu and Anita DeWitt 9/21/14 */// The Math library is needed for its random() functionimport java.lang.Math;/** * This class simulates a volleyball or racquetball game * between players/teams A and B, based on the probability * that A will win a volley.  1000 games are simulated, * with the probability of A winning a volley being  * 0.40, 0.41, ..., 0.59, 0.60 . */public class Game1Iter2Alt {    public String game; // either "racquetball" or "volleyball"    public boolean winByTwo;    public int numberOfGames;    /**     * Constructor specifies whether racquetball or volleyball     * will be simulated (default racquetball) and      * the number of games to be simulated     * Constructor also uses the racquetball/volleyball      * information to determine if players of the game      * must win by 2 or 1, respectively.     */    public Game1Iter2Alt (String simGame, int simNumGames)    {	game = simGame;	numberOfGames = simNumGames;   	winByTwo = simGame.equals("volleyball");    }        public static boolean printGame = true;    /**     * Format a probability (a number between 0.0 and 1.0)     * as a 2-character integer percentage, followed by a     * "%" character.     */    public static String formatPercent (double value)    {	String str = "" + Math.round(value * 100.0);	while (str.length() < 3)	    str = " " + str;	return str + "%";    }	    /**     * Determine if player with first score has won     * @parms firstScore, secondScore are scores of opposing players/teams     * @returns true if player with first score has won; false otherwise     */    public boolean won (int firstScore, int secondScore)    {      // check if first person has won	return ((firstScore >= 15)		&& ((! winByTwo)		    || (firstScore >= secondScore + 2)));    }    /**	 * allows player with first score to continue serving, 	 * until player has won game or lost volley	 * @parms probWinVolley is probability that player with first score	 *                      wins volley	 *        firstScore, secondScore are scores of the two players/teams	 * @returns final score of server */    public int serve (double probWinVolley, int firstScore, int secondScore)    {   while (Math.random() < probWinVolley)	    {  firstScore++;	       if (won (firstScore, secondScore))		   break;	    }	return firstScore;    }    /**     * Play one game of racquetball or volleyball to conclusion     * @parms  probWinVolley specifies the likelihood the server wins a volley     * @returns winner of game: either "A" or "B"     */    public String playUntilWin (double probWinVolley)     {	//  start at 0-0	int AScore = 0;	int BScore = 0;	// continue indefinitely 	//     (until A wins after A's serve or B wins after B's serve)	while (true)	    {		// A serves		AScore = serve (probWinVolley, AScore, BScore);		// stop if A has won	    if (won (AScore, BScore))	    { if (printGame)			System.out.println (" - Scores (A/B):  " 					+ AScore 					+ " / " + BScore);		return "A";		}	    // B serves	    BScore = serve (1.0 - probWinVolley, BScore, AScore);	    // stop if B has won	    if (won (BScore, AScore))	    { if (printGame)			System.out.println (" - Scores (A/B):  " 					+ AScore 					+ " / " + BScore);  		return "B";		}	}     }    /**     * Run simulation of 1000 games for probability of "A" winning     *   a volley covering the range 0.40, 0.41, ..., 0.59, 0.60.     * For each probability of "A" winning,     *   simulate games with Player/Team A always serving first     *   print one line with the percentage of volleys won by A and B      *     and percentage of games won by A and B     */    public void simulateGames ()    {   // print headings	System.out.println ("\nSimulation of " + game			    + " based on " + numberOfGames + " games");	System.out.println ("Must win by 2:  " + winByTwo);	System.out.println ();	System.out.println ("    Probabilities         Percentage");	System.out.println (" for winning volley        of Wins");	System.out.println ("     A       B            A        B");        System.out.println ();		// Simulate games for 40% to 60% probabilities for A	for (int prob40To60 = 40; prob40To60 <= 60; prob40To60++)	    {	      double probWinVolley = prob40To60 / 100.0; 	      // Simulate games for a given probability	      int AWins = 0;  // at first neither A nor B has won any games	      int BWins = 0;	      for (int i = 0; i < numberOfGames; i++)		  { // tally winner of game		    if (playUntilWin (probWinVolley).equals("A"))			AWins++;		    else			BWins++;		  }	      System.out.println ("   "			  + formatPercent(probWinVolley)   + "    " 			  + formatPercent(1-probWinVolley) + "         "			  + formatPercent(((double) AWins) / numberOfGames)			  + "     "			  + formatPercent(((double) BWins) / numberOfGames));	    }	System.out.println ("\nEnd of Simulation\n");    }	/**	 * @parm args is a command-line argument specifies the type of game	 *       "racquetball" indicates server need not win by 2 points	 *       "volleyball" indicates server must win by 2 points	 *       no parameter or other parameter defaults to "racquetball"	 */    public static void main (String [] args)    {	Game1Iter2Alt rac1 = new Game1Iter2Alt ("racquetball", 1000);	rac1.simulateGames() ;	Game1Iter2Alt rac2 = new Game1Iter2Alt ("volleyball", 500);	rac2.simulateGames();    }	}6.It justifies our augmentations to the code in that we can see the steps in between each side gaining a point. The sample output can be explained mathematically and that can certainly be helped along by tracing. Adding the traces into out code allows us to see the volleys that were one twice in a row. There is a lot occuring in the calculations of the simulation and as developers we can control how we montior those calculations so we can best modify out code to suite our needs. Tracing is a helpful tool in this pursuit.